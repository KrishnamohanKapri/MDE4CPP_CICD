name: Runner Build

on:
  workflow_dispatch:
    inputs:
      components:
        description: 'Space-separated component list in build order'
        required: true
        type: string
      pr_number:
        description: 'PR number for feedback'
        required: false
        type: string
      commit_sha:
        description: 'Commit SHA to checkout'
        required: true
        type: string
      event_type:
        description: 'Event type (pull_request or push)'
        required: false
        type: string
        default: 'workflow_dispatch'

jobs:
  build-components:
    runs-on: self-hosted
    steps:
      - name: Set project directory
        id: set_dir
        run: |
          # Search for repository in common locations
          # The runner may execute as root even if service runs as another user
          POSSIBLE_PATHS=(
            "/home/krish/Projects/MDE4CPP_CICD"
            "/home/$(whoami)/Projects/MDE4CPP_CICD"
            "$HOME/Projects/MDE4CPP_CICD"
            "/opt/MDE4CPP_CICD"
            "/var/lib/MDE4CPP_CICD"
          )
          
          PROJECT_DIR=""
          for path in "${POSSIBLE_PATHS[@]}"; do
            if [ -d "$path/.git" ]; then
              PROJECT_DIR="$path"
              echo "Found repository at: $PROJECT_DIR"
              break
            fi
          done
          
          # If still not found, try to find it using find command (limited to /home)
          if [ -z "$PROJECT_DIR" ]; then
            echo "Searching for repository in /home..."
            FOUND_PATH=$(find /home -maxdepth 4 -type d -name "MDE4CPP_CICD" -path "*/.git" -prune -o -type d -name "MDE4CPP_CICD" -print 2>/dev/null | head -1)
            if [ -n "$FOUND_PATH" ] && [ -d "$FOUND_PATH/.git" ]; then
              PROJECT_DIR="$FOUND_PATH"
              echo "Found repository via search: $PROJECT_DIR"
            fi
          fi
          
          if [ -z "$PROJECT_DIR" ] || [ ! -d "$PROJECT_DIR/.git" ]; then
            echo "‚ùå Error: Repository not found"
            echo "Searched paths:"
            printf '  - %s\n' "${POSSIBLE_PATHS[@]}"
            echo "Current user: $(whoami)"
            echo "HOME: $HOME"
            exit 1
          fi
          
          echo "project_dir=$PROJECT_DIR" >> $GITHUB_OUTPUT
          echo "PROJECT_DIR=$PROJECT_DIR" >> $GITHUB_ENV
          echo "Using project directory: $PROJECT_DIR"
          echo "Current commit: $(cd $PROJECT_DIR && git rev-parse HEAD 2>/dev/null || echo 'N/A')"
      
      - name: Save current state (last known good commit)
        id: save_state
        working-directory: ${{ env.PROJECT_DIR }}
        run: |
          # Save current commit before updating
          CURRENT_COMMIT=$(git rev-parse HEAD)
          echo "last_good_commit=$CURRENT_COMMIT" >> $GITHUB_OUTPUT
          echo "LAST_GOOD_COMMIT=$CURRENT_COMMIT" >> $GITHUB_ENV
          echo "Saved current commit (last known good): $CURRENT_COMMIT"
          # Also try to get main branch commit as fallback
          git fetch origin main 2>/dev/null || true
          MAIN_COMMIT=$(git rev-parse origin/main 2>/dev/null || echo "")
          if [ -n "$MAIN_COMMIT" ]; then
            echo "main_commit=$MAIN_COMMIT" >> $GITHUB_ENV
            echo "Main branch commit: $MAIN_COMMIT"
          fi
      
      - name: Update existing repository
        working-directory: ${{ env.PROJECT_DIR }}
        run: |
          echo "Updating repository to commit: ${{ inputs.commit_sha }}"
          
          # Check for uncommitted changes and handle them
          if ! git diff-index --quiet HEAD --; then
            echo "Warning: Uncommitted changes detected. Stashing them..."
            git stash push -m "CI workflow stash $(date +%Y%m%d_%H%M%S)"
          fi
          
          # Fetch latest changes (including all branches and PR refs)
          git fetch origin --all --prune
          
          # Try to fetch the specific commit if it's not found
          if ! git cat-file -e ${{ inputs.commit_sha }} 2>/dev/null; then
            echo "Commit not found locally, fetching from origin..."
            git fetch origin ${{ inputs.commit_sha }}:${{ inputs.commit_sha }} || true
          fi
          
          # Checkout the specified commit
          git checkout ${{ inputs.commit_sha }} || git checkout -b temp-${{ inputs.commit_sha }} ${{ inputs.commit_sha }}
          
          # Reset to ensure clean state
          git reset --hard ${{ inputs.commit_sha }}
          
          # Clean any untracked files (optional, be careful with this)
          git clean -fd || echo "Git clean skipped"
          
          echo "Repository updated successfully"
          echo "Current commit: $(git rev-parse HEAD)"
          echo "Git status:"
          git status --short
      
      - name: Parse components
        id: parse
        working-directory: ${{ env.PROJECT_DIR }}
        run: |
          COMPONENTS="${{ inputs.components }}"
          echo "Components to build: $COMPONENTS"
          
          # Convert space-separated to array
          COMPONENT_ARRAY=($COMPONENTS)
          echo "Number of components: ${#COMPONENT_ARRAY[@]}"
          
          # Store as JSON array for later use
          echo "components=$(echo $COMPONENTS | tr ' ' '\n' | jq -R . | jq -s .)" >> $GITHUB_OUTPUT
      
      - name: Setup environment
        working-directory: ${{ env.PROJECT_DIR }}
        run: |
          echo "Setting up build environment..."
          cd docker
          docker compose config > /dev/null || echo "Docker Compose config check passed"
      
      - name: Build components sequentially
        id: build
        working-directory: ${{ env.PROJECT_DIR }}
        run: |
          cd docker
          COMPONENTS="${{ inputs.components }}"
          FAILED_COMPONENTS=""
          SUCCESSFUL_COMPONENTS=""
          
          # Convert space-separated to array
          read -ra COMPONENT_ARRAY <<< "$COMPONENTS"
          
          # Check if "full" or "build-full" is requested
          if [[ " ${COMPONENT_ARRAY[@]} " =~ " full " ]] || [[ " ${COMPONENT_ARRAY[@]} " =~ " build-full " ]]; then
            echo "=========================================="
            echo "Running full build (build-full service)"
            echo "=========================================="
            if docker compose up --build build-full; then
              echo "‚úì Full build succeeded"
              echo "successful_components=full" >> $GITHUB_OUTPUT
              echo "failed_components=" >> $GITHUB_OUTPUT
            else
              echo "‚úó Full build failed"
              echo "successful_components=" >> $GITHUB_OUTPUT
              echo "failed_components=full" >> $GITHUB_OUTPUT
              exit 1
            fi
            exit 0
          fi
          
          # Otherwise, build components individually
          for component in "${COMPONENT_ARRAY[@]}"; do
            echo "=========================================="
            echo "Building component: $component"
            echo "=========================================="
            
            # Determine service names based on component
            GENERATE_SERVICE="generate-${component}"
            COMPILE_SERVICE="compile-${component}"
            BUILD_SERVICE="build-${component}"
            
            # Check if services exist in docker-compose.yml
            if docker compose config --services | grep -q "^${GENERATE_SERVICE}$"; then
              echo "Running generate service: $GENERATE_SERVICE"
              if docker compose up --build "$GENERATE_SERVICE"; then
                echo "‚úì Generate succeeded for $component"
              else
                echo "‚úó Generate failed for $component"
                FAILED_COMPONENTS="$FAILED_COMPONENTS $component"
                continue
              fi
            fi
            
            if docker compose config --services | grep -q "^${COMPILE_SERVICE}$"; then
              echo "Running compile service: $COMPILE_SERVICE"
              if docker compose up --build "$COMPILE_SERVICE"; then
                echo "‚úì Compile succeeded for $component"
              else
                echo "‚úó Compile failed for $component"
                FAILED_COMPONENTS="$FAILED_COMPONENTS $component"
                continue
              fi
            elif docker compose config --services | grep -q "^${BUILD_SERVICE}$"; then
              # Some components only have build service (generators, infrastructure)
              echo "Running build service: $BUILD_SERVICE"
              if docker compose up --build "$BUILD_SERVICE"; then
                echo "‚úì Build succeeded for $component"
              else
                echo "‚úó Build failed for $component"
                FAILED_COMPONENTS="$FAILED_COMPONENTS $component"
                continue
              fi
            else
              echo "Warning: No service found for component $component"
              echo "Available services:"
              docker compose config --services | grep -E "(generate|compile|build)-" | head -10
            fi
            
            SUCCESSFUL_COMPONENTS="$SUCCESSFUL_COMPONENTS $component"
          done
          
          # Output results
          echo "successful_components=$SUCCESSFUL_COMPONENTS" >> $GITHUB_OUTPUT
          echo "failed_components=$FAILED_COMPONENTS" >> $GITHUB_OUTPUT
          
          # Fail if any component failed
          if [ -n "$FAILED_COMPONENTS" ]; then
            echo "Failed components: $FAILED_COMPONENTS"
            exit 1
          fi
      
      - name: Recover on failure (revert to last known good commit)
        if: failure()
        working-directory: ${{ env.PROJECT_DIR }}
        run: |
          echo "‚ùå Build failed! Recovering to last known good state..."
          
          # Determine recovery commit (prefer last good, fallback to main)
          if [ -n "${{ env.LAST_GOOD_COMMIT }}" ]; then
            RECOVERY_COMMIT="${{ env.LAST_GOOD_COMMIT }}"
            echo "Reverting to last known good commit: $RECOVERY_COMMIT"
          elif [ -n "${{ env.main_commit }}" ]; then
            RECOVERY_COMMIT="${{ env.main_commit }}"
            echo "Reverting to main branch: $RECOVERY_COMMIT"
          else
            echo "‚ö†Ô∏è  No recovery commit found. Trying to checkout main branch..."
            git fetch origin main
            RECOVERY_COMMIT="origin/main"
          fi
          
          # Revert repository
          git checkout $RECOVERY_COMMIT || git checkout -b recovery $RECOVERY_COMMIT
          git reset --hard $RECOVERY_COMMIT
          
          echo "‚úÖ Repository reverted to: $RECOVERY_COMMIT"
          echo "Current commit: $(git rev-parse HEAD)"
          
          # Rebuild to restore artifacts
          echo "Rebuilding to restore working artifacts..."
          cd docker
          
          # Get the components that were supposed to be built
          COMPONENTS="${{ inputs.components }}"
          read -ra COMPONENT_ARRAY <<< "$COMPONENTS"
          
          # Check if full build was requested
          if [[ " ${COMPONENT_ARRAY[@]} " =~ " full " ]] || [[ " ${COMPONENT_ARRAY[@]} " =~ " build-full " ]]; then
            echo "Running full build to restore artifacts..."
            docker compose up --build build-full || echo "Full build failed during recovery"
          else
            # Rebuild individual components
            for component in "${COMPONENT_ARRAY[@]}"; do
              echo "Rebuilding component: $component"
              
              GENERATE_SERVICE="generate-${component}"
              COMPILE_SERVICE="compile-${component}"
              BUILD_SERVICE="build-${component}"
              
              # Try to rebuild the component
              if docker compose config --services | grep -q "^${GENERATE_SERVICE}$"; then
                docker compose up --build "$GENERATE_SERVICE" || echo "Generate failed for $component"
              fi
              
              if docker compose config --services | grep -q "^${COMPILE_SERVICE}$"; then
                docker compose up --build "$COMPILE_SERVICE" || echo "Compile failed for $component"
              elif docker compose config --services | grep -q "^${BUILD_SERVICE}$"; then
                docker compose up --build "$BUILD_SERVICE" || echo "Build failed for $component"
              fi
            done
          fi
          
          echo "‚úÖ Recovery complete. Repository and artifacts restored to working state."
      
      - name: Build summary
        if: always()
        run: |
          echo "## Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ job.status }}" = "success" ]; then
            echo "‚úÖ **All components built successfully**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Built components:**" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            echo "${{ steps.build.outputs.successful_components || 'N/A' }}" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Build failed**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "‚ö†Ô∏è **Repository has been reverted to last known good commit and artifacts have been rebuilt.**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            FAILED="${{ steps.build.outputs.failed_components }}"
            SUCCESSFUL="${{ steps.build.outputs.successful_components }}"
            
            if [ -n "$FAILED" ]; then
              echo "**Failed components:**" >> $GITHUB_STEP_SUMMARY
              echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
              echo "$FAILED" >> $GITHUB_STEP_SUMMARY
              echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            else
              echo "**Failed components:** (Build failed before component build started)" >> $GITHUB_STEP_SUMMARY
            fi
            
            echo "" >> $GITHUB_STEP_SUMMARY
            
            if [ -n "$SUCCESSFUL" ]; then
              echo "**Successful components:**" >> $GITHUB_STEP_SUMMARY
              echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
              echo "$SUCCESSFUL" >> $GITHUB_STEP_SUMMARY
              echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            else
              echo "**Successful components:** (Build failed before component build started)" >> $GITHUB_STEP_SUMMARY
            fi
          fi
      
      - name: Post PR comment
        if: github.event_name == 'pull_request' || inputs.pr_number != ''
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = '${{ inputs.pr_number || github.event.pull_request.number }}';
            const status = '${{ job.status }}';
            const successful = '${{ steps.build.outputs.successful_components }}';
            const failed = '${{ steps.build.outputs.failed_components }}';
            
            if (!prNumber) {
              console.log('No PR number available, skipping comment');
              return;
            }
            
            let body = '## üî® Build Results\n\n';
            
            if (status === 'success') {
              body += '‚úÖ **All components built successfully!**\n\n';
              body += `**Built components:** ${successful || 'N/A'}\n`;
            } else {
              body += '‚ùå **Build failed**\n\n';
              if (failed) {
                body += `**Failed components:** ${failed}\n`;
              }
              if (successful) {
                body += `**Successful components:** ${successful}\n`;
              }
            }
            
            body += `\n**Commit:** ${context.sha.substring(0, 7)}\n`;
            body += `**Workflow:** [View details](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})\n`;
            
            try {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: body
              });
            } catch (error) {
              console.error('Error posting comment:', error);
            }

